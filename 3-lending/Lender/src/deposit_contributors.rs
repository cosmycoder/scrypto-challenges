use scrypto::prelude::*;
use std::cmp;

#[derive(NonFungibleData, Describe, Encode, Decode, TypeId, Clone)]
struct ContributorAllocation {
    pub contributor_id : NonFungibleId,
    pub amount : Decimal
}

#[derive(Describe, Encode, Decode, TypeId)]
struct AllocatedFund 
{
    pub id : NonFungibleId,
    pub total_amount : Decimal, 
    pub contributor_allocations : Vec<ContributorAllocation>, // keeps track of how many funds were taken from each contributor in order to lock this fund
    pub restored_funds : Vault
}

#[derive(NonFungibleData, Describe, Encode, Decode, TypeId, Clone)]
struct Contributor 
{
    pub id : NonFungibleId, 
    pub amount : Decimal,
    pub locked_amount : Decimal,
    pub accepts_new_allocations : bool
}



blueprint! {
    // While DeFi will revolutionize banking because everyone will be able to participate in financial apps, a major downside is that tends to become very fragmented
	// This class aims to fill that gap so that people can join together their funds and provide larger funds for dapps 
    // If the aim is to replace banks with DeFi, the solution is to provide benefits for ordinary people to join their funds
    // `DepositContributors` is a struct that manages funds windrawal from a vault that is split between multiple contributors in a similar manner to a cyclic resource allocator
    // where each contribution occupies a continuous amount of tokens
    // There's no such thing as a sustainable constant APY, that's why the approach of this struct is that each contributor earns based on how many allocation are made with his contribution, 
    // just like a shop earns based on the sell amount
    // In order to make it worth it for the owner of the deposit to accept contributors, he will always have priority to allocations 
    // For all the other contributors, the algorithm works in a queue manner. Chunks of free tokens are taken from the queue for allocations so that everyone gets their turn in a cyclic manner
    // The benefit for the owner is that the amount of losses is mitigated because it is split between all participants of the deposit 
    // The contributors benefit from using the perks of the owner (like a high level trusted network rank)
    // So it is a win-win for both. 
    
    // Improvements in the future:
    // This component can be extended so that the owner will get a small percentage of the profit generated by contributor funds
    /// Properties:
    /// 
    /// * `total_funds`: This is the total amount of funds that have been contributed to the deposit.
    /// * `contributors`: This is a vector of Contributor structs. Each Contributor struct contains the
    /// following properties:
    /// * `allocated_funds`: This is a vector of AllocatedFund structs. This is where we store the amount of
    /// funds allocated to each contributor.
    /// * `contributor_nft_resource`: This is the resource address of the NFT that will be minted for each
    /// contributor.
    /// * `contributor_nft_minter_badge`: This is the address of the NFT minter badge that is used to mint
    /// the contributor NFTs.
    struct DepositContributors
    {
        total_funds : Vault,
        contributors : Vec<Contributor>, // stores contributors to the funds
        allocated_funds : Vec<AllocatedFund>,
        contributor_nft_resource : ResourceAddress,
        contributor_nft_minter_badge: Vault,
        current_index : usize,
        owner_id : NonFungibleId
    }


    impl DepositContributors 
    {
        pub fn instantiate(initial_deposit: Bucket, owner_badge : ResourceAddress) -> (ComponentAddress, Bucket) {
            
            let access_rules: AccessRules = AccessRules::new()
            .method("create_deposit", rule!(require(owner_badge)))
            .method("close_deposit", rule!(require(owner_badge)))
            .method("withdraw_funds", rule!(require(owner_badge)))
            .method("close_withdrawal", rule!(require(owner_badge)))
            .method("add_funds", rule!(require(owner_badge)));

            let auth_token = ResourceBuilder::new_fungible()
            .divisibility(DIVISIBILITY_NONE)
            .metadata("name", "Admin authority for minting contributor nfts")
            .burnable(rule!(allow_all), LOCKED)
            .initial_supply(Decimal::one());

            let contributor_resource = ResourceBuilder::new_non_fungible()
            .mintable(rule!(require(auth_token.resource_address())), LOCKED)
            .burnable(rule!(allow_all), LOCKED)
            .metadata("LoanContributorBadge", "NFT awarded to contributors to the funds")
            .updateable_non_fungible_data(rule!(require(auth_token.resource_address())), LOCKED)
            .no_initial_supply();


            let admin_id = NonFungibleId::random();
            let contributor = Contributor {
                id : admin_id.clone(),
                amount : initial_deposit.amount(),
                locked_amount : Decimal::zero(),
                accepts_new_allocations : true
            };

            let admin_contributor_nft = auth_token.authorize(|| {
                borrow_resource_manager!(contributor_resource)
                    .mint_non_fungible(&NonFungibleId::random(), contributor.clone())
            });

            let mut contributors_vector = Vec::<Contributor>::new();
            contributors_vector.push(contributor);

            let component = Self {
                total_funds : Vault::with_bucket(initial_deposit),
                contributors : contributors_vector,
                allocated_funds : Vec::<AllocatedFund>::new(),
                contributor_nft_resource : contributor_resource,
                contributor_nft_minter_badge : Vault::with_bucket(auth_token),
                current_index : 0,
                owner_id : admin_id.clone()
            }
            .instantiate()
            .add_access_check(access_rules)
            .globalize();

            return (component, admin_contributor_nft)   
        }

        /// Takes a bucket of funds, adds it to the total funds, and mints a new contributor NFT
        /// 
        /// Arguments:
        /// 
        /// * `funds`: The amount of funds to deposit.
        /// 
        /// Returns:
        /// 
        /// The return value is a bucket of the non-fungible token type.
        pub fn create_deposit(&mut self, funds : Bucket) -> Bucket {
            assert!(funds.resource_address() == self.total_funds.resource_address(), "not matching resource type");
            assert!(!funds.is_empty(), "cannot deposit empty bucket");

            let new_contributor_id = NonFungibleId::random();
            let contributor = Contributor {
                id : new_contributor_id,
                amount : funds.amount(),
                locked_amount : Decimal::zero(),
                accepts_new_allocations : true
            };
            
            self.total_funds.put(funds);

            return self.contributor_nft_minter_badge.authorize(|| {
                borrow_resource_manager!(self.contributor_nft_resource)
                    .mint_non_fungible(&NonFungibleId::random(), contributor)
            })
        }

        /// > The function increases the amount of funds a contributor has deposited by the amount of funds in
        /// the `funds` bucket
        /// 
        /// Arguments:
        /// 
        /// * `funds`: The amount of funds to be deposited.
        /// * `contributor_nft`: The NFT that represents the contributor.
        /// 
        /// Returns:
        /// 
        /// The contributor_nft is being returned.
        pub fn increase_deposit(&mut self, funds : Bucket, contributor_nft : Bucket) -> Bucket {
            assert!(funds.resource_address() == self.total_funds.resource_address(), "not matching resource type");
            assert!(contributor_nft.resource_address() == self.contributor_nft_resource, "invalid contributor nft");
            assert!(!funds.is_empty(), "cannot deposit empty bucket");

            match self.contributors.iter_mut().find(|x| x.id == contributor_nft.non_fungible::<Contributor>().id())
            {
                Some(contributor) => {
                    contributor.amount += funds.amount();
                    self.contributor_nft_minter_badge.authorize(|| {
                        contributor_nft.non_fungible::<Contributor>().update_data(contributor.clone())
                    });
                },
                None => assert!(false, "could not find a contributor with this nft")
            }
            
            self.total_funds.put(funds);

            return contributor_nft
        }

        /// It takes a contributor NFT, checks that it's valid, removes the contributor from the list of
        /// contributors, burns the NFT, and returns the amount of money that the contributor has in the
        /// contract
        /// 
        /// Arguments:
        /// 
        /// * `contributor_nft`: The NFT that represents the contributor.
        /// 
        /// Returns:
        /// 
        /// The total amount of funds that the contributor has in the contract or returns back the contract if his funds are locked in a withdrawal
        pub fn close_deposit(&mut self, contributor_nft : Bucket) -> Bucket {
            assert!(contributor_nft.resource_address() == self.contributor_nft_resource, "invalid contributor nft");

            let contributor_index = self.contributors.iter().position(|x| x.id == contributor_nft.non_fungible::<Contributor>().id());
            assert!(contributor_index.is_some(), "could not find a contributor with this nft");

            let mut contributor = &mut self.contributors[contributor_index.unwrap()];
            if contributor.locked_amount > Decimal::zero() { 
                contributor.accepts_new_allocations = false;
                return contributor_nft
            }

            contributor_nft.burn();
            return self.total_funds.take(contributor.amount)
        }

        /// > The function cycles through the contributors and gets their deposits to allocate the funds needed for withdrawal
        /// The owner of the deposit gets priority and then the other contributors are processed in order
        /// Arguments:
        /// 
        /// * `amount`: The amount of tokens to withdraw
        pub fn withdraw_funds(&mut self, amount : Decimal) -> (Bucket, NonFungibleId) {
            assert!(amount > Decimal::zero() && amount <= self.total_funds.amount(), "Not enough liquidity to supply this loan!");

            let random_id = NonFungibleId::random();
            let mut allocated_fund = AllocatedFund { 
                id : random_id.clone(),
                total_amount : Decimal::zero(), 
                contributor_allocations : Vec::new(),
                restored_funds : Vault::new(self.total_funds.resource_address())
            };

            // the owner always gets priority
            let contributor_index = self.contributors.iter().position(|x| x.id == self.owner_id);
            if contributor_index.is_some() {
                let contributor = &mut self.contributors[contributor_index.unwrap()];
                let mut available_contribution = contributor.amount - contributor.locked_amount;
                if available_contribution > amount {
                    available_contribution = amount;
                }

                if available_contribution > Decimal::zero() && contributor.accepts_new_allocations {
                    contributor.locked_amount += available_contribution;
                    allocated_fund.contributor_allocations.push( ContributorAllocation { 
                        contributor_id: contributor.id.clone(), 
                        amount : available_contribution });

                    allocated_fund.total_amount += available_contribution;
                }

            }
            
            // cycle through the contributors and get their deposits to build this allocation
            // we always start from the index of the last one we visited so that everyone gets their chance to contribute equally 
            // if we end up at the end, we start again from the beginning
			let starting_index = self.current_index;
            while allocated_fund.total_amount < amount {
                let contributor = &mut self.contributors[self.current_index];
                let mut available_contribution = contributor.amount - contributor.locked_amount;

                if available_contribution <= Decimal::zero() || !contributor.accepts_new_allocations { // already occupied
                    continue;
                }

                available_contribution = cmp::min(available_contribution, amount - allocated_fund.total_amount);

                contributor.locked_amount += available_contribution;

                allocated_fund.contributor_allocations.push(ContributorAllocation { 
                    contributor_id: contributor.id.clone(), 
                    amount : available_contribution });

                allocated_fund.total_amount += available_contribution;

                self.current_index += 1;
                if self.current_index == self.contributors.len() - 1 {
                    self.current_index = 0;
                }

				if starting_index == self.current_index { // safety mechanism so that we don't do infinite loop 
					break;
				}
            }

            assert!(allocated_fund.total_amount == amount, "Insuficient funds to withdraw the desired amount of tokens");    

            self.allocated_funds.push(allocated_fund);

            return (self.total_funds.take(amount), random_id)
        }


        /// Adds funds to restore an existing withdrawal
        /// 
        /// Arguments:
        /// 
        /// * `funds`: The amount of funds to add to the bucket.
        /// * `allocation_id`: The id of the fund that you want to add funds to.
        pub fn add_funds(&mut self, funds : Bucket, allocation_id : NonFungibleId) {
        
            let allocated_fund_index = self.allocated_funds.iter().position(|x| x.id == allocation_id);
            assert!(allocated_fund_index.is_some(), "couldn't find any fund associated with this id");

            let allocated_fund =  &mut self.allocated_funds[allocated_fund_index.unwrap()];

			
			for contributor_allocation in allocated_fund.contributor_allocations.iter() {
				let contribution_percent = allocated_fund.total_amount / contributor_allocation.amount;
				let restored_amount_for_contributor = funds.amount() / contribution_percent;

				match self.contributors.iter_mut().find(|x| x.id == contributor_allocation.contributor_id) {
					Some(contributor) => { 
						contributor.amount += restored_amount_for_contributor;  
						contributor.locked_amount = cmp::min(Decimal::zero(), contributor.locked_amount - restored_amount_for_contributor)},
					None => assert!(false, "Could not find contributor")
				}
			}

            allocated_fund.restored_funds.put(funds);
        }

        /// The function takes an allocation id, finds the allocation associated with that id, removes it from
        /// the allocated funds list, calculates the profit or loss made on that allocation, and then
        /// distributes the profit or loss to the contributors based on how much they contributed
        /// 
        /// Arguments:
        /// 
        /// * `allocation_id`: The id of the allocation you want to close
        /// 
        /// Returns:
        /// 
        /// The difference between the amount restored and the total amount.
        pub fn close_withdrawal(&mut self, allocation_id : NonFungibleId) -> Decimal { 
            let allocated_fund_index = self.allocated_funds.iter().position(|x| x.id == allocation_id);
            assert!(allocated_fund_index.is_some(), "couldn't find any fund associated with this id");

            let mut allocated_fund = self.allocated_funds.remove(allocated_fund_index.unwrap());
            let amount_restored = allocated_fund.restored_funds.amount();
            let total_amount = allocated_fund.total_amount;

			 // some of the funds were lost, all the contributors deposit amount will decrease to account for the lost funds
            if amount_restored < total_amount {
				let mut total_contribution = Decimal::zero();
				for contributor in self.contributors.iter() {
					total_contribution += contributor.amount + contributor.locked_amount;
				}
                let total_losses = total_amount - amount_restored;

                for contributor in self.contributors.iter_mut() {
                    let contribution_percent = total_contribution / contributor.amount;
                    let distributed_loss = total_losses / contribution_percent;
                    contributor.amount -= distributed_loss;
                }
            }

            self.total_funds.put(allocated_fund.restored_funds.take_all());


            return amount_restored - total_amount
        }

        pub fn get_deposit_resource_type(& self) -> ResourceAddress 
        {
            return self.total_funds.resource_address()
        }
    }
}



