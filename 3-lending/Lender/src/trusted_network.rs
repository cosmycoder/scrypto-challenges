use scrypto::prelude::*;

#[derive(NonFungibleData)]
pub struct TrustedNetworkClient {
    pub points : Decimal, // for loans, the points accumulated could be the amount of $ that lenders made based on interest
    pub member_interaction_history : HashMap<NonFungibleId, Decimal>, // we track the members that this client interacted with to establish if the client accumulated a large number of points with a certain member 
}

#[derive(NonFungibleData)]
pub struct TrustedPartnerNetworkMember {
    pub component : ComponentAddress,
    pub inviter : NonFungibleId, // id of the person that invited this member
    pub client_nft_resource_address: ResourceAddress,
}

blueprint! {

    // This component is similar to a guild. It represents a group of partners that have trust in each other that they are not bad actors. 
    // Only leader can invite other members and new leaders are promoted by the votes of at least half the active leaders 
    // Thea idea behind the trusted partner network is that without KYC you cannot trust clients unless you have a network of trusted partners that are verified and don't act maliciously 
    // Without this kind of network design, there is no way to guarantee that a client is a friend of a random lender and will do loans back and forth between them to gain fidelity levels 
    // once the client gained enough fidelity levels to borrow with less collateral then he can go to other members, borrow from them and will keep the borrowed money (which is more than his collateral)
    // without returning anything. 

    // The creator of this component will provide a list of fidelity levels that both clients and members will have to gain in order to access better offers
    // One metric for fidelity levels could be the amount of profit that the client generated inside the network by taking loans for example.
    // The more profit he generated by taking loans, the further levels he gains and can take loans with less collateral.
    // Deciding the exact levels and benefits is a tough decision to make and needs to be careful analyzed by the creators based on the risk/reward. 
    // If clients can gain fidelity levels fast, then they should not have too much collateral reduction. 
    // The levels should be geared towards certain borrowers. For example, institutions will borrow large sums and generate a huge profit so a 'TrustedPartnerNetwork' for them 
    // should have levels adjusted to the amount of tokens that big players are borrowing. 

    // Clients that don't repay their loan have their client_nfts burnt and they will need to start again from 0 in order to gain fidelity levels.
    // Banning clients is useless because without KYC they can always create a new account and start from there. 
    // If crypto will be regulated and clients will have a badge that will link to a real-life person (like a nation ID), then banning clients is certainly something that can be done
    // but as long as there is no way to associated an account to that person, then is no valid use case for banning. 

    // This struct also has a fallback mechanism for punishing members that helped bad clients gain fidelity levels
    // We trace the history of the client and register the loss he caused as minus points to the trustworthiness of the member
    // In order to gain back his trustworthiness he must register profits from other clients to regain enough levels to account for the losses
    // Clients will be encouraged to loan from members with similar trustworthiness. If a client with higher fidelity will try to loan from a low fidelity member, then
    // that client will only have a discount proportional to the minimum between his level and the members level 

    // Improvements in the future:
    // What can be improved is to add a membership fee and the profits from the membership fees will be used to account for the losses similar to an insurance
    struct TrustedPartnerNetwork {
        network_name : String,
        fidelity_levels : Vec<Decimal>,
        fidelity_discounts : Vec<Decimal>,
        auth_vault: Vault,
        member_resource: ResourceAddress,
        client_resource: ResourceAddress,
        leaders : Vec<NonFungibleId>,
        //leaders_required_for_promotion : u32,
        amount_lost_points_for_banning_members : u32,
        // if nb recommendation points is >= 50 of the total leader count, then a member can be promoted to leader and can issue invites
        member_promotion_votes : HashMap<NonFungibleId, Vec<NonFungibleId>>, 
        // the best way would be to store this inside the member nft, but since the loss of one member affects the trustworthiness of the previous members that interacted with that client
        // we have no way of updating their nfts until they try to make a new loan. This could be transformed into a temporary list in the future, only storing the losses 
        // of that member until he tries to interact with a new client, but then the member nft cannot be soulbound because this component need to update it
        member_trustworthiness_points : HashMap<NonFungibleId, Decimal>
    }

    impl TrustedPartnerNetwork {
        pub fn instantiate(name : String, client_fidelity_levels : Vec<Decimal>, client_fidelity_discounts : Vec<Decimal>) -> (ComponentAddress, Bucket) {
            assert!(client_fidelity_levels.len() == client_fidelity_discounts.len(), "the number of fidelity levels should be equal to the discounts");
            let auth_token = ResourceBuilder::new_fungible()
            .divisibility(DIVISIBILITY_NONE)
            .metadata("name", "Admin authority for TrustedNetwork")
            .burnable(rule!(allow_all), LOCKED)
            .initial_supply(Decimal::one());
            
            let member_nft_resource = ResourceBuilder::new_non_fungible()
            .mintable(rule!(require(auth_token.resource_address())), LOCKED) // only leaders can mint new member nfts
            .burnable(rule!(allow_all), LOCKED) // if someone doesn't want to be a member anymore, he can burn it
            .metadata("name", name.clone())
            .metadata("status", "member")
            .updateable_non_fungible_data(rule!(require(auth_token.resource_address())), LOCKED) // nobody can change a member data
            .restrict_withdraw(rule!(deny_all), LOCKED) // this resource is soulbound and cannot moved from one user to another
            .no_initial_supply();

            let client_nft_resource = ResourceBuilder::new_non_fungible()
            .mintable(rule!(require(member_nft_resource)), LOCKED) // only the owner can mint new leader nfts
            .burnable(rule!(allow_all), LOCKED) // if someone doesn't want to be a client anymore, he can burn it
            .metadata("name", name.clone())
            .metadata("status", "client")
            .updateable_non_fungible_data(rule!(require(auth_token.resource_address()) || require(member_nft_resource)), LOCKED)
            .no_initial_supply();

            let auth_proof = auth_token.create_proof();
            
            let trusted_network_id = NonFungibleId::random();

            let mut leaders = Vec::<NonFungibleId>::new();
            leaders.push(trusted_network_id.clone());

            let this = Self {
                network_name : name,
                fidelity_levels : client_fidelity_levels.clone(),
                fidelity_discounts : client_fidelity_discounts.clone(),
                auth_vault : Vault::with_bucket(auth_token),
                member_resource : member_nft_resource,
                client_resource : client_nft_resource,
                leaders : leaders,
                amount_lost_points_for_banning_members : 0, // not used for the moment, but if some members have negative trustworthiness then they could be forbidden to mint new clients, but this requires another interaction with this component
                member_promotion_votes : HashMap::new(), // if nb recommendation points is >= 50 of the total leader count, then a member can be promoted to leader and can issue invites
                member_trustworthiness_points : HashMap::new(), // banned clients that closed loans at a loss for lenders. Note that only clients that have advanced enough fidelity will have reduction
            }
            .instantiate()
            .globalize();

            ComponentAuthZone::push(auth_proof);
            let member_nft = borrow_resource_manager!(member_nft_resource).mint_non_fungible(&trusted_network_id.clone(), TrustedPartnerNetworkMember {
                        component : this.into(),
                        inviter : NonFungibleId::from_u32(0),
                        client_nft_resource_address : client_nft_resource,
                    });
            ComponentAuthZone::pop();

            return (this, member_nft)
        }

        // TODO : find a way to test if the member that receives this badge is of the same type as the lender to avoid hacks where scammers try to duplicate the lender component with a fake one
        pub fn mint_new_member_badge(&mut self, leader_proof : Proof) -> Bucket {
            assert!(leader_proof.resource_address() == self.member_resource && leader_proof.amount() == Decimal::one(), "invalid member proof");

            let ids = leader_proof.non_fungible_ids();
            let leader_id = ids.iter().next().unwrap();

            assert!(self.leaders.contains(&leader_id));

            let member_data = leader_proof.non_fungible::<TrustedPartnerNetworkMember>().data();

            return self.auth_vault.authorize(|| {
                borrow_resource_manager!(self.member_resource)
                    .mint_non_fungible(&NonFungibleId::random(), crate::trusted_network::TrustedPartnerNetworkMember {
                        component : member_data.component,
                        inviter : leader_id.clone(),
                        client_nft_resource_address : self.member_resource
                    })
            })
        }

        pub fn mint_new_client_nft(&mut self) -> Bucket {
            // assert!(member_proof.resource_address() == self.member_resource && member_proof.amount() == Decimal::one(), "invalid member proof");
            // let member_data = member_proof.non_fungible::<TrustedPartnerNetworkMember>().data();

            // let ids = member_proof.non_fungible_ids();
            // let member_id = ids.iter().next().unwrap();

            return self.auth_vault.authorize(|| {
                borrow_resource_manager!(self.client_resource)
                    .mint_non_fungible(&NonFungibleId::random(), TrustedNetworkClient {
                        points : Decimal::zero(), 
                        member_interaction_history : HashMap::new()
                    })
            })
        }

        /// If a leader recommends a member for promotion, and the member has been recommended by at least half
        /// of the leaders, then the member is promoted to leader
        /// 
        /// Arguments:
        /// 
        /// * `member_proof`: Proof of ownership of the member's token
        /// * `member_id`: The id of the member to be promoted
        pub fn recommend_member_for_promotion(&mut self, member_proof : Proof, member_id : NonFungibleId) { 
            assert!(member_proof.resource_address() == self.member_resource && member_proof.amount() == Decimal::one(), "invalid member proof");

            let ids = member_proof.non_fungible_ids();
            let leader_id = ids.iter().next().unwrap();

            assert!(self.leaders.contains(&leader_id));

            match self.member_promotion_votes.get_mut(&member_id) {
                Some(votes) =>  {
                    assert!(!votes.contains(&leader_id), "member was already voted for promotion");
                    votes.push((*leader_id).clone());
                }
                None => {
                    let mut recommendation_vec = Vec::<NonFungibleId>::new();
                    recommendation_vec.push((*leader_id).clone());
                    self.member_promotion_votes.insert(member_id.clone(), recommendation_vec);
                }
            }

            if self.member_promotion_votes.get(&member_id).unwrap().len() * 2 >= self.leaders.len() {
                self.leaders.push(member_id.clone());
            }
        }

        /// The function takes a member proof and a client NFT and returns the client NFT and the fidelity
        /// level of the client
        /// The fidelity is the minimum between the member level and client level. 
        /// The idea is that clients with higher fidelity won't be able to borrow more from member than are not trustworthy
        /// to avoid members that could be scammers
        /// Members also need to build their trust to unlock higher fidelity clients by generating more profit
        /// Arguments:
        /// 
        /// * `member_proof`: Proof of membership of the member
        /// * `client_nft`: The client's NFT
        pub fn get_client_fidelity_level(&self, member_proof : Proof, client_nft : Bucket) -> (Bucket, Decimal) {
            assert!(member_proof.resource_address() == self.member_resource && member_proof.amount() == Decimal::one(), "invalid member proof");
            assert!(!client_nft.is_empty() && client_nft.resource_address() == self.client_resource, "invalid client");

            let ids = member_proof.non_fungible_ids();
            let member_id = ids.iter().next().unwrap();

            let mut client_data = client_nft.non_fungible::<TrustedNetworkClient>().data();
            let member_points : Decimal;
            match client_data.member_interaction_history.get_mut(&member_id) {
                Some(member_profit) =>  {
                    member_points = *member_profit;
                }
                None => {
                    member_points = Decimal::zero();
                }
            }


            let mut points = client_data.points;
            if member_points < client_data.points {
                points = member_points;
            }

            let mut fidelity_level = 0 as usize;
            if points > Decimal::zero() {
                for idx in 1..self.fidelity_levels.len() -1 {
                    if points >= self.fidelity_levels[idx] {
                        fidelity_level += 1;
                    }
                }
            }

            return (client_nft, self.fidelity_levels[fidelity_level])
        }

        /// > This function takes a member proof, a client NFT and a profit value and updates the client NFT
        /// with the profit value and updates the trustworthiness of the member that provided the proof
        /// If the profit is negative, then we distribut the loss as minus points to the members that interacted with that client
        /// 
        /// Arguments:
        /// 
        /// * `member_proof`: Proof of the member that is interacting with the client
        /// * `client_nft`: The client's NFT
        /// * `profit`: the profit or loss that the client made
        /// 
        /// Returns:
        /// 
        /// The client_nft is being returned.
        pub fn register_client_profit(&mut self, member_proof : Proof, client_nft : Bucket, profit : Decimal) -> Bucket {
            assert!(member_proof.resource_address() == self.member_resource && member_proof.amount() == Decimal::one(), "invalid member proof");
            assert!(!client_nft.is_empty() && client_nft.resource_address() == self.client_resource, "invalid client");
            
            let ids = member_proof.non_fungible_ids();
            let member_id = ids.iter().next().unwrap();

            let client_data = client_nft.non_fungible::<TrustedNetworkClient>().data();
            

            // distribute the loss so that it affects the trustworthiness of the members that interacted previously with this client
            // the idea is that we want to avoid the case where a client and a member are friends, the client gets a lot of points through that member and can get loans with less collateral for example
            // if that client then rugpulls on another member and doesn't pay his loan, then we look through the history and reduce the trustworthiness of the members he interacted with
            if profit < Decimal::zero() {
                let mut sum = Decimal::zero();
                for val in client_data.member_interaction_history.values() {
                    sum += *val;
                }

                for (key,val) in client_data.member_interaction_history.iter() {
                    let percent =  *val  / sum;
                    let points_lost_for_member = profit * percent;
    
                    if *key == *member_id { // we don't want to reduce the trustworthiness if the client only interacted with this member
                        continue;
                    }
    
                    let option2 = self.member_trustworthiness_points.get_mut(&key);
                    if option2.is_some() {
                        *option2.unwrap() -= points_lost_for_member;
                    } else {
                        self.member_trustworthiness_points.insert(key.clone(), points_lost_for_member);
                    }
                }
            } 
            else {
                let option2 = self.member_trustworthiness_points.get_mut(&member_id);
                if option2.is_some() {
                    *option2.unwrap() += profit;
                } else {
                    self.member_trustworthiness_points.insert(member_id.clone(), profit);
                }
            }


            // Now update the client data
            let mut client_data = client_nft.non_fungible::<crate::trusted_network::TrustedNetworkClient>().data();

            client_data.points += profit;
            
            match client_data.member_interaction_history.get_mut(&member_id) {
                Some(member_profit) =>  {
                    *member_profit += profit;
                }
                None => {
                    client_data.member_interaction_history.insert(member_id.clone(), profit);
                }
            }

            self.auth_vault.authorize(|| {
            client_nft.non_fungible::<crate::trusted_network::TrustedNetworkClient>().update_data(client_data); });

            return client_nft
        }
    }
}