//! This blueprint describes an invoice that ad brokers create for their users (advertisers and and slot providers).
//! It allows settling all payments from advertisers to ad slot providers and ad brokers on the network.
//!
//! Each invoice contains ad cost items on the one side and ad slot revenue items on the other side. Ad cost items
//! represent the costs that must be paid by advertisers. Ad slot revenue items represent the revenue that has been
//! generated by ad slots.
//!
//! An invoice can contain cost and revenue items for multiple ads and ad slots from different advertisers resp. ad
//! slot providers. An invoice may contain multiple cost and revenue items for the same ad resp. the same ad slot. This
//! allows ad brokers to iteratively update the invoice before settling it. This can make more transparent how much
//! of an ad's budget has been depleted and gives advertisers the opportunity to replenish it.
//! The amount of costs and revenues must be equal before the invoice can be "settled".
//!
//! Invoices have an optimistic design that requires honest and fair behavior by all participants. Especially, the ad
//! brokers have the obligation to act diligently when creating invoices. They must monitor the data coming in through
//! their tracking API (which records all ad placements and ad clicks) for fraud or generated clicks and exclude clicks
//! they deem invalid. With every invoice they must provide a link to a document (e.g. PDF,
//! spreadsheet, etc.) and an accompanying hash, with detailed information on how the consolidated cost and revenue
//! items of the invoice have been calculated.
//!
//! If advertisers and ad slot providers have opted-in to it, their own
//! tracking APIs will also be invoked every time an ad is placed and clicked. They should use their own data to
//! verify the invoice is correct. Advertisers are required to confirm their ad costs before the invoice can be settled
//! and ad slot providers can withdraw their earnings. This ensures, funds cannot be "stolen" by secretly creating an
//! invoice without informing the advertiser. If any advertiser does not confirm their ad costs before the confirmation
//! deadline passes, the invoice will be considered as disputed. An invoice can also be disputed by advertisers and
//! ad slot providers explicitly if they detect any irregularities.
//! If an invoice has been disputed it enters arbitration. The board of arbitrators (a DAO) will then check the invoice
//! and decide to either reject the invoice as invalid or "force" accept it. In order to be able to do this, arbitrators
//! must also run their own tracking API and record ad placement and click events.
//! If an invoice has been accepted, ad slot providers can withdraw their earnings (their revenues minus the ad broker's
//! fee) and the ad broker can withdraw their fee.
//! If an invoice has been rejected, advertisers can reclaim their ad costs and the ad broker must create a corrected
//! invoice.
//!
//! At the moment RadSense does not support any form of slashing. Slashing is not strictly necessary as any false claims
//! or disputes can be resolved in arbitration. However, slashing might be used as an instrument for reducing trolling
//! by individual bad actors and reducing the burden on arbitrators.
//!
//! Invoices are explicitly modeled as components because it would be difficult to model them as NFRs, which might be
//! ones instinctive approach. Because ads can be placed in possibly thousands of ad slots and ad slots can display
//! possibly thousands of ads, there is just too much data to put it all on the network. Ad brokers must consolidate
//! this data and provide just the costs and revenues that have been incurred by an ad resp. generated by an ad slot.
//! Even then, it would be quite unlikely that this data would fit inside a single NFR. Likely, transactions involving
//! such a single invoice NFR would get too big and exceed the networks transaction cost limit. Therefore, only the ad
//! cost items and ad slot revenue items of the invoice are modeled as NFRs. The invoice itself is modeled as a
//! component that provides a logical wrapper around those items. It also provides methods to e.g. confirm ad costs or
//! withdraw funds that have been earned by ad slots for their providers.
//!
//! The invoice component is also structured in a way that the transaction costs that are incurred by calling its
//! various methods are unlikely to exceed the networks cost limit:
//! - ad brokers can add cost and revenue items to the invoice in batches. This is necessary as just adding thousands of
//! items at once in one transaction would likely exceed any sane cost limits that will be in place when the Babylon
//! upgrade is rolled out to mainnet.
//! - advertisers can confirm their ad costs in batches
//! - ad slot providers can claim their revenues in batches
use crate::dao_kit::voting_system::Vote;
use crate::rad_sense::{Ad, AdSlot, RadSenseAddresses, RadSenseComponent};
use crate::utils::{Minter, NonFungibleConfig};
use derive_new::new;
use scrypto::prelude::*;

blueprint! {

    struct Invoice {
        /// The component address of the parent RadSense component
        rad_sense_component: ComponentAddress,
        /// A vault holding a badge for accessing privileged methods of the RadSense component
        rad_sense_access_badge: Vault,
        /// A struct holding all relevant RadSense resource addresses
        rsa: RadSenseAddresses,
        /// The invoices config
        config: InvoiceConfig,
        /// Central minting authority for creating and minting all of the Invoice component's resources
        minter: Minter,
        /// A vault holding all [AdCost] invoice items
        ad_costs: Vault,
        /// A vault holding all [AdSlotRevenue] invoice items
        ad_slot_revenues: Vault,
        /// The sum of all ad costs
        total_ad_costs: Decimal,
        /// The sum of all ad slot revenues
        total_ad_slot_revenues: Decimal,
        /// All funds that have been diverted from the parent RadSense component to this Invoice component
        funds: Vault,
        /// A vault that will hold all fees that are claimable by the ad broker once the invoice has been accepted
        fees: Vault,
        /// The current state of the invoice
        state: InvoiceState,
    }

    impl Invoice {
        /// Instantiates a new Invoice component without globalizing it
        ///
        /// # Arguments
        /// - `config` - The invoice's config
        /// - `rad_sense_component` - The address of the parent RadSense component
        /// - `rad_sense_access_badge` - The badge that may be used to access privileged methods of the RadSense
        /// component
        ///
        /// # Returns
        /// - The instantiated, local Invoice component
        /// - A struct holding all relevant resource addresses that are associated with the invoice
        pub fn instantiate(
            config: InvoiceConfig,
            rad_sense_component: ComponentAddress,
            rad_sense_access_badge: Bucket,
        ) -> (InvoiceComponent, InvoiceAddresses) {
            config.assert_valid();

            // Create a minting authority that can be used to create new resources and for minting them
            let minter =
                Minter::new(ResourceBuilder::new_fungible().divisibility(DIVISIBILITY_NONE).initial_supply(dec!(1)));

            // Define a resource to represent ad cost items on the invoice
            let ad_cost_resource = minter
                .new_non_fungible_resource("AdCost Token", NonFungibleConfig::new().updatable_non_fungible_data(true));

            // Define a resource to represent ad slot revenue items on the invoice
            let ad_slot_revenue_resource = minter.new_non_fungible_resource(
                "AdSlotRevenue Token",
                NonFungibleConfig::new().updatable_non_fungible_data(true),
            );

            let component = Self {
                rad_sense_component,
                rad_sense_access_badge: Vault::with_bucket(rad_sense_access_badge),
                rsa: config.rad_sense_addresses.clone(),
                minter,
                ad_costs: Vault::new(ad_cost_resource),
                ad_slot_revenues: Vault::new(ad_slot_revenue_resource),
                total_ad_costs: dec!(0),
                total_ad_slot_revenues: dec!(0),
                funds: Vault::new(RADIX_TOKEN),
                fees: Vault::new(RADIX_TOKEN),
                state: InvoiceState::new_preparing(),
                config,
            }
            .instantiate();
            let invoice_addresses = InvoiceAddresses { ad_cost_resource, ad_slot_revenue_resource };
            (component, invoice_addresses)
        }

        /// Instantiates a new Invoice component and globalizes it
        ///
        /// # Arguments
        /// - `config` - The invoice's config
        /// - `rad_sense_component` - The address of the parent RadSense component
        /// - `rad_sense_access_badge` - The badge that may be used to access privileged methods of the RadSense component
        /// - `arbitration_dao_admin_badge` - The admin badge of the arbitration DAO. This is needed to set some access
        /// rules.
        ///
        /// # Returns
        /// - The address of the instantiated and globalized Invoice component
        /// - A struct holding all relevant resource addresses that are associated with the invoice
        pub fn instantiate_global(
            config: InvoiceConfig,
            rad_sense_component: ComponentAddress,
            rad_sense_access_badge: Bucket,
            arbitration_dao_admin_badge: ResourceAddress,
        ) -> (ComponentAddress, InvoiceAddresses) {
            let broker_address = NonFungibleAddress::new(
                config.rad_sense_addresses.ad_broker_resource,
                config.ad_broker_user_id.clone(),
            );
            let access_rules = AccessRules::new()
                .method("add_invoice_items", rule!(require(broker_address.clone())))
                .method("publish", rule!(require(broker_address.clone())))
                .method("confirm_ad_costs", rule!(allow_all))
                .method("claim_ad_slot_earnings", rule!(allow_all))
                .method("claim_fees", rule!(require(broker_address)))
                .method("mark_invoice_as_accepted_or_disputed", rule!(allow_all))
                .method("dispute_invoice", rule!(allow_all))
                .method("reject_invoice", rule!(require(arbitration_dao_admin_badge)))
                .method("force_accept_invoice", rule!(require(arbitration_dao_admin_badge)))
                .method("reclaim_ad_cost_payment", rule!(allow_all));

            let (mut component, invoice_addresses) =
                Self::instantiate(config, rad_sense_component, rad_sense_access_badge);
            component.add_access_check(access_rules);
            (component.globalize(), invoice_addresses)
        }

        /// Adds the given `items` to the invoice.
        ///
        /// # Arguments
        /// - `items` - A vec with [InvoiceItem]s to add. This vec can contain both [AdCost] as well as [AdSlotRevenue]
        /// items. For each AdCost item that is added, the associated amount of funds will be withdrawn from the
        /// RadSense component and deposited into this Invoice component.
        ///
        /// # Returns
        /// 1. A vec containing the IDs of all added AdCost items
        /// 2. A vec containing the IDs of all added AdSlotRevenue items
        ///
        /// **Access control:** Can only be called by the ad broker that created this Invoice component
        ///
        /// **Panics:**
        /// - if the invoice is not in state [InvoiceState::Preparing]
        /// - if adding an AdCost item would exceed the available budget of the ad that it references
        pub fn add_invoice_items(&mut self, items: Vec<InvoiceItem>) -> (Vec<NonFungibleId>, Vec<NonFungibleId>) {
            // Assert we are in state Preparing
            assert!(
                matches!(self.state, InvoiceState::Preparing { .. }),
                "Invoice items can only be added in state preparing"
            );

            // Iterate over all item and...
            let mut ad_cost_ids = vec![];
            let mut ad_slot_revenue_ids = vec![];
            for item in items {
                match item {
                    // ...either add it to teh ad cost side of the invoice
                    InvoiceItem::AdCost { ad_id, amount } => {
                        let ad_cost_id = self.add_ad_cost_item(AdCost::new(ad_id, amount, AdCostState::Unconfirmed));
                        ad_cost_ids.push(ad_cost_id);
                    }
                    // ...or add it to the ad slot revenue side
                    InvoiceItem::AdSlotRevenue { ad_slot_id, amount } => {
                        let ad_slot_revenue_id =
                            self.add_ad_slot_revenue_item(AdSlotRevenue::new(ad_slot_id, amount, false));
                        ad_slot_revenue_ids.push(ad_slot_revenue_id);
                    }
                }
            }

            // Return both a list of the IDs of all added ad cost items as well as a list of all added ad slot revenue
            // items
            (ad_cost_ids, ad_slot_revenue_ids)
        }

        /// Ads the given `ad_cost` item to this invoice, returning it's NonFungibleId.
        fn add_ad_cost_item(&mut self, ad_cost: AdCost) -> NonFungibleId {
            let ad_cost_amount = ad_cost.amount;

            // Load the associated Ad
            let ad_rm = borrow_resource_manager!(self.rsa.ad_resource);
            let ad: Ad = ad_rm.get_non_fungible_data(&ad_cost.ad_id); // This panics if the referenced ad does not exist

            // Ensure that the broker that owns this invoice is also the broker for the referenced ad
            assert_eq!(
                ad.ad_broker_user_id(),
                &self.config.ad_broker_user_id,
                "This invoice's broker does not match that of the ad"
            );

            // Withdraw the funds from the RadSense component
            let rad_sense_component: RadSenseComponent = self.rad_sense_component.into();
            let funds = self
                .rad_sense_access_badge
                .authorize(|| rad_sense_component.claim_ad_budget(ad_cost.ad_id.clone(), ad_cost.amount))
                .unwrap_or_else(|_| panic!("Ad budget exceeded"));
            // And put the funds into the invoice's vault
            self.funds.put(funds);

            // Mint an AdCost NFR and put it into the vault of unconfirmed aad costs
            let ad_cost_id = NonFungibleId::random();
            self.ad_costs.put(self.minter.mint_non_fungible_with_id(
                self.ad_costs.resource_address(),
                ad_cost,
                &ad_cost_id,
            ));

            // Finally update the total amount on the invoice's cost side
            self.total_ad_costs += ad_cost_amount;

            ad_cost_id
        }

        /// Adds the given `ad_slot_revenue``item to this invoice, returning its NonFungibleID.
        fn add_ad_slot_revenue_item(&mut self, ad_slot_revenue: AdSlotRevenue) -> NonFungibleId {
            let ad_slot_revenue_amount = ad_slot_revenue.amount;

            // Get the associated AdSlot
            let ad_slot_rm = borrow_resource_manager!(self.rsa.ad_slot_resource);
            let ad_slot: AdSlot = ad_slot_rm.get_non_fungible_data(&ad_slot_revenue.ad_slot_id);

            // Ensure that the broker that owns this invoice is also the broker for the referenced ad slot
            assert!(
                ad_slot.approved_broker_user_ids().contains(&self.config.ad_broker_user_id),
                "This invoice's broker is not an allowed broker of the referenced ad slot"
            );

            // Mint a new AdSLotRevenue NFR and put it into a vault
            let ad_slot_revenue_id = NonFungibleId::random();
            self.ad_slot_revenues.put(self.minter.mint_non_fungible_with_id(
                self.ad_slot_revenues.resource_address(),
                ad_slot_revenue,
                &ad_slot_revenue_id,
            ));

            // Finally update the total amount on the invoice's revenue side
            self.total_ad_slot_revenues += ad_slot_revenue_amount;

            ad_slot_revenue_id
        }

        /// Publishes the invoice. After publishing advertisers can confirm their ad cost items and ad slot providers
        /// can dispute the invoice if they think it contains an error.
        ///
        /// # Arguments
        /// - `proof_document_url` - A document containing all the necessary details for verifying the ad costs and
        ///ad slot revenue items that are listed on the invoice.
        /// - `proof_document_hash` - A SHA256 hash of the proof_document_url so that users can verify it's authenticity
        ///
        /// **Access control:** Can only be called by the broker that created this Invoice component.
        ///
        /// **Panics:**
        /// - if the invoice is not in state [InvoiceState::Preparing]
        /// - if the invoice contains no items
        /// - if the sum of all ad costs items does not match the sum of all ad slot revenue items
        pub fn publish(&mut self, proof_document_url: String, proof_document_hash: String) {
            // Verify we are in state Preparing
            match &self.state {
                InvoiceState::Preparing => {
                    // Make sure the invoice is not empty
                    assert!(self.total_ad_costs > dec!(0), "Cannot publish an empty invoice");
                    // Make sure it is consistent and the cost side is equal to the revenue side
                    assert_eq!(
                        self.total_ad_costs, self.total_ad_slot_revenues,
                        "Inconsistent invoice: costs and revenues do not match"
                    );

                    // Calculate the confirmation deadline
                    let confirmation_deadline = Runtime::current_epoch() + self.config.confirmation_period;
                    // Determine how many ad cost items belong to this invoice and use this number when publishing the
                    // invoice (advancing it's state)
                    let unconfirmed_ad_costs_count = self.ad_costs.amount();
                    self.state = InvoiceState::Published {
                        proof_document_url,
                        proof_document_hash,
                        confirmation_deadline,
                        unconfirmed_ad_costs_count,
                    };
                }
                _ => panic!("Invoices can only be confirmed when in state Preparing"),
            }
        }

        /// Confirm the ad cost items in the given set of `ad_cost_ids`.
        ///
        /// # Arguments:
        /// - `ad_cost_ids` - The IDs of all AdCost items to confirm
        /// - `ads` - A proof containing all Ad NFRs that are referenced by the ad cost items that should be confirmed
        ///
        /// # Panics:
        /// - if the invoice is not in state Published
        /// - if the provided proof is invalid/insufficient
        /// - if one of the referenced ad cost items has already been confirmed before
        ///
        /// **Access control:** Can be called by anyone in possession of the required Ad NFRs.
        pub fn confirm_ad_costs(&mut self, ad_cost_ids: HashSet<NonFungibleId>, ads: Proof) {
            // Make sure the invoice is in state published
            match &self.state {
                InvoiceState::Published {
                    proof_document_url,
                    proof_document_hash,
                    confirmation_deadline,
                    unconfirmed_ad_costs_count,
                } => {
                    // Update the state with the new unconfirmed_ad_costs_count
                    // This is just the old number minus the size of the given ad_cost_ids set
                    self.state = InvoiceState::Published {
                        proof_document_url: proof_document_url.to_owned(),
                        proof_document_hash: proof_document_hash.to_owned(),
                        confirmation_deadline: *confirmation_deadline,
                        unconfirmed_ad_costs_count: *unconfirmed_ad_costs_count - ad_cost_ids.len(),
                    }
                }
                _ => panic!("AdCosts can only be confirmed when the invoice is in state Published"),
            }

            // Get the IDs of all Ads that belong to the referenced AdCosts by iterating over all items
            let ad_cost_rm = borrow_resource_manager!(self.ad_costs.resource_address());
            let mut referenced_ad_ids = BTreeSet::<NonFungibleId>::new();
            for ad_cost_id in ad_cost_ids {
                // Get the ad cost data
                let mut ad_cost: AdCost = ad_cost_rm.get_non_fungible_data(&ad_cost_id);
                // Verify it is still unconfirmed. Items must not confirmed multiple times as this would mess up the
                // counts in this component
                assert!(
                    matches!(ad_cost.state, AdCostState::Unconfirmed),
                    "The AdCost item with ID {} has already been confirmed",
                    ad_cost_id
                );
                // Set the state of teh cost item to confirmed
                ad_cost.state = AdCostState::Confirmed;
                // Remember the ID of the ad that was referenced by the cost item
                referenced_ad_ids.insert(ad_cost.ad_id.clone());
                // Save the updated ad cost item to the ledge
                self.minter.update_non_fungible(self.ad_costs.resource_address(), &ad_cost_id, ad_cost);
            }

            // Validate that the provided proof contains all required Ads
            // This ensures that the person confirming the AdCosts is the persons who is holding/owns the Ad NFR.
            // Only this person is allowed to confirm the AdCost (i.e. confirm payment).
            ads.validate_proof(ProofValidationMode::ValidateContainsNonFungibles(
                self.rsa.ad_resource,
                referenced_ad_ids,
            ))
            .expect("Invalid/insufficient proof of AdCost ownership provided");
        }

        /// Claim the earnings for one or more ad slot revenue items.
        ///
        /// Here, earnings are understood as the ad slots' revenues minus the broker fees. If e.g. the combined revenue
        /// of all referenced ad slots is 100 XRD and the ad broker charges a 10% fee, the claimable earnings will
        /// amount to 90 XRD.
        ///
        /// # Arguments:
        /// - `ad_slot_revenue_ids` - A set of the IDs of all AdSlotRevenue items for which the revenue should be
        /// claimed
        /// - `ad_slots` - A proof containing all AdSlot NFRs that are referenced by the ad slot revenue items
        ///
        /// # Returns:
        /// - A bucket with the combined earnings of all ad slot items that where passed to this method.
        ///
        /// # Panics:
        /// - if the invoice is not in state Accepted
        /// - if the provided proof is invalid/insufficient
        /// - if the earnings of one of the referenced ad slot revenue items have already been claimed before
        ///
        /// **Access control:** Can be called by anyone in possession of the required AdSlot NFRs.
        pub fn claim_ad_slot_earnings(
            &mut self,
            ad_slot_revenue_ids: HashSet<NonFungibleId>,
            ad_slots: Proof,
        ) -> Bucket {
            // Assert the invoice has been accepted, i.e. all AdCosts have been paid and it has not been disputed
            let is_last_user_to_claim_revenues = match &self.state {
                InvoiceState::Accepted { unclaimed_ad_slot_revenues_count } => {
                    // Update the state with the new unclaimed_ad_slot_revenues_count
                    let new_count = *unclaimed_ad_slot_revenues_count - ad_slot_revenue_ids.len();
                    self.state = InvoiceState::Accepted { unclaimed_ad_slot_revenues_count: new_count };
                    new_count == dec!(0) //is_last_user_to_claim_revenues
                }
                _ => panic!("Revenues can only been claimed when in state Accepted"),
            };

            // Validate that the caller is indeed the owner of the ad slot for which the revenue should be claimed
            let ad_slot_revenue_rm = borrow_resource_manager!(self.ad_slot_revenues.resource_address());
            let mut referenced_ad_slot_ids = BTreeSet::<NonFungibleId>::new();
            let mut total_revenue_amount = dec!(0);
            for ad_slot_revenue_id in ad_slot_revenue_ids {
                let mut ad_slot_revenue: AdSlotRevenue = ad_slot_revenue_rm.get_non_fungible_data(&ad_slot_revenue_id);
                // Ensure that the earning for this slot are not claimed twice
                assert!(
                    !ad_slot_revenue.claimed,
                    "The earnings for AdSlotRevenue(ID={}) have already been claimed",
                    ad_slot_revenue_id
                );
                // Remember that the revenues for this slot have been claimed
                ad_slot_revenue.claimed = true;
                // Update how much funds can be withdrawn by the caller
                total_revenue_amount += ad_slot_revenue.amount;
                // Remember the ID of the ad slot that was referenced by this item
                referenced_ad_slot_ids.insert(ad_slot_revenue.ad_slot_id.clone());
                // Save the updated item to the ledger
                self.minter.update_non_fungible(
                    self.ad_slot_revenues.resource_address(),
                    &ad_slot_revenue_id,
                    ad_slot_revenue,
                );
            }

            // Validate that the provided proof contains all required AdSlots
            // This ensures that the person claiming the AdSlotRevenues is the persons who is holding/owns the AdSlot NFR.
            ad_slots
                .validate_proof(ProofValidationMode::ValidateContainsNonFungibles(
                    self.rsa.ad_slot_resource,
                    referenced_ad_slot_ids,
                ))
                .expect("Invalid/insufficient proof of AdSlotRevenue ownership provided");

            // Finally, claim the revenues
            if is_last_user_to_claim_revenues {
                // If this user is the last one to claim their revenues, they can simply take all remaining funds
                // This gets around any potential rounding issues where some few Attos might be missing from the vault
                self.funds.take_all()
            } else {
                // If this user is not the last one to claim their revenues, calculate the actual claimable amount after
                // the broker fees have been deducted
                let claimable_revenue_amount = total_revenue_amount * (dec!(1) - self.config.broker_fee_ratio);
                self.funds.take(claimable_revenue_amount)
            }
        }

        /// Let's the ad broker claim the fees that they earned for their services.
        ///
        /// The fees will only be available in the vault after the invoice's state has advanced Accepted.
        ///
        /// # Returns
        /// A bucket with the broker's fees
        ///
        /// **Access control:** Can only be called by the ad broker that created this invoice. A broker user badge must
        /// be present in the AuthZone.
        pub fn claim_fees(&mut self) -> Bucket {
            self.fees.take_all()
        }

        /// Mark the invoice as either accepted if all advertisers confirmed their AdCosts, or as disputed if some
        /// advertisers did not confirm their AdCosts.
        ///
        /// # Returns:
        /// The invoice's new state
        ///
        /// # Panics:
        /// - if the invoice is not in state published
        /// - if the confirmation deadline has not passed yet
        ///
        /// **Access control:** Can be called by anyone
        pub fn mark_invoice_as_accepted_or_disputed(&mut self) -> InvoiceState {
            // Ensure the invoice is in state Published
            let all_ad_costs_confirmed = match &self.state {
                InvoiceState::Published { confirmation_deadline, unconfirmed_ad_costs_count, .. } => {
                    // Assert the confirmation deadline has passed
                    assert!(
                        Runtime::current_epoch() > *confirmation_deadline,
                        "Can only accept an invoice after the confirmation deadline has passed"
                    );
                    // Return whether all ad costs have been confirmed
                    unconfirmed_ad_costs_count == &dec!(0)
                }
                _ => panic!("Invoice can only be accepted when in state Published"),
            };

            // Check if all ad costs have been confirmed
            if all_ad_costs_confirmed {
                // If this is the case, calculate the brokers fee and put it into a separate vault
                let fees_amount = self.funds.amount() * self.config.broker_fee_ratio;
                self.fees.put(self.funds.take(fees_amount));
                // Advance the state of the invoice to accepted
                let unclaimed_ad_slot_revenues_count = self.ad_slot_revenues.amount();
                self.state = InvoiceState::new_accepted(unclaimed_ad_slot_revenues_count);
            } else {
                // If not every ad cost item has been confirmed, advance the state to Disputed
                self.state = InvoiceState::new_disputed(Disputers::AllWithUnconfirmedAdCosts);
                self.begin_arbitration();
            }
            self.state.clone()
        }

        /// Dispute this invoice.
        ///
        /// An invoice can be disputed by both advertisers and ad slot providers. The caller must provide proof of an
        /// Ad or AdSlot NFR for which an AdCost item resp. an AdSlotRevenue item is listed on this invoice.
        ///
        /// # Arguments:
        /// - `dispute_invoice_request`: A wrapper object containing the ID of an AdCost/AdSlotRevenue item and a proof
        /// of the associated Ad/AdSlot NFR. Any AdCost/AdSlotRevenue item can be referenced in this request as it is
        /// only used to verify that the caller has a legitimate interest to dispute the invoice.
        ///
        /// # Panics if:
        /// - an invalid request has been provided
        /// - If the invoice is not in state [InvoiceState::Published]. Only one person can dispute the invoice. After
        /// this has happened, arbitrators must diligently verify the invoice and find all irregularities.
        ///
        /// **Access control:** Can be called by anyone that has an AdCost or AdSlotRevenue item listed on this invoice
        /// and has the associated Ad/AdSlot to prove it.
        pub fn dispute_invoice(&mut self, dispute_invoice_request: DisputeInvoiceRequest) {
            // Ensure the invoice is in state Published
            match &self.state {
                InvoiceState::Published { confirmation_deadline, .. } => {
                    // Ensure the confirmation deadline has not passed yet
                    assert!(
                        &Runtime::current_epoch() <= confirmation_deadline,
                        "Invoices cannot be disputed after the confirmation deadline has passed"
                    )
                }
                _ => panic!("Invoices can only be disputed when in state Published"),
            }

            let disputer = match dispute_invoice_request {
                // Handle a dispute request coming from an advertiser
                DisputeInvoiceRequest::DisputeAdCost { ad_cost_id, ad_proof } => {
                    // Load the ad cost's data to get the referenced Ad ID...
                    let ad_cost: AdCost = load_non_fungible_data(self.ad_costs.resource_address(), ad_cost_id);
                    // ...and validate that the required Ad proof was provided
                    let ad_proof = ad_proof
                        .validate_proof(ProofValidationMode::ValidateContainsNonFungible(NonFungibleAddress::new(
                            self.rsa.ad_resource,
                            ad_cost.ad_id,
                        )))
                        .expect("Invalid proof of AdCost ownership");

                    // Load the Ad's data
                    let ad: Ad = ad_proof.non_fungible().data();
                    // Get the Advertiser ID
                    let advertiser_id = ad.advertiser_user_id().to_owned();
                    // Return the advertiser's address
                    NonFungibleAddress::new(self.rsa.advertiser_resource, advertiser_id)
                }
                // Handle a dispute request coming from an ad slot provider
                DisputeInvoiceRequest::DisputeAdSlotRevenue { ad_slot_revenue_id, ad_slot_proof } => {
                    // Load the ad slot revenue's data to get the referenced AdSlot ID...
                    let ad_slot_revenue: AdSlotRevenue =
                        load_non_fungible_data(self.ad_slot_revenues.resource_address(), ad_slot_revenue_id);
                    // ...and validate that the required AdSlot proof was provided
                    let ad_slot_proof = ad_slot_proof
                        .validate_proof(ProofValidationMode::ValidateContainsNonFungible(NonFungibleAddress::new(
                            self.rsa.ad_slot_resource,
                            ad_slot_revenue.ad_slot_id,
                        )))
                        .expect("Invalid proof of AdSlotRevenue ownership");

                    // Load the AdSlot's data
                    let ad_slot: AdSlot = ad_slot_proof.non_fungible().data();
                    // Get the AdSLotProvider ID
                    let ad_slot_provider_id = ad_slot.ad_slot_provider_user_id().to_owned();
                    // Return the ad slot provider's address
                    NonFungibleAddress::new(self.rsa.ad_slot_provider_resource, ad_slot_provider_id)
                }
            };
            // Update the invoice's state
            self.state = InvoiceState::new_disputed(Disputers::IndividualUser(disputer));
            // Place the invoice in arbitration
            self.begin_arbitration();
        }

        /// Places the invoice into arbitration by creating an associated vote in the arbitration DAO.
        fn begin_arbitration(&self) -> Vote {
            self.rad_sense_access_badge.authorize(|| {
                let rad_sense_component: RadSenseComponent = self.rad_sense_component.into();
                let invoice_address = Runtime::actor().as_component().0;
                rad_sense_component.create_invoice_arbitration_vote(invoice_address)
            })
        }

        /// Reject the invoice as invalid.
        ///
        /// # Panics:
        /// - if the invoice is not in state Disputed
        ///
        /// **Access control:** Can only be called via a vote by the arbitration DAO (needs the arbitration DAO's admin
        /// badge).
        pub fn reject_invoice(&mut self) {
            // Ensure the invoice is in state Disputed
            match &self.state {
                InvoiceState::Disputed(_) => {
                    // Set the state to Rejected
                    self.state = InvoiceState::new_rejected();
                }
                _ => panic!("Invoices can only be rejected when in state Disputed"),
            }
        }

        /// Accept the invoice ignoring any objections.
        ///
        /// # Panics:
        /// - if the invoice is not in state Disputed
        ///
        /// **Access control:** Can only be called via a vote by the arbitration DAO (needs the arbitration DAO's admin
        /// badge).
        pub fn force_accept_invoice(&mut self) {
            // Ensure the invoice is in state Disputed
            match &self.state {
                InvoiceState::Disputed(_) => {
                    // Set the state to Accepted
                    let unclaimed_ad_slot_revenues_count = self.ad_slot_revenues.amount();
                    self.state = InvoiceState::new_accepted(unclaimed_ad_slot_revenues_count);
                }
                _ => panic!("Invoices can only be force accepted when in state Disputed"),
            }
        }

        /// Reclaim the payment for an AdCost. This will transfer the associated funds back to the RadSense component
        /// and increase the associated Ad's budget.
        ///
        /// # Arguments
        /// - `ad_cost_id` - The ID of the AdCost item for which payment should be reclaimed
        /// reclaim their payment
        ///
        /// # Panics
        /// - if the invoice is not in state Rejected
        /// - if the payment has already been reclaimed
        ///
        /// **Access control:** Anyone can call this method as this just transfers funds back to the RadSense component
        /// to the benefit of the Ad's budget.
        pub fn reclaim_ad_cost_payment(&mut self, ad_cost_id: NonFungibleId) {
            // Make sure the invoice has been rejected in arbitration.
            // Only then is it ok for advertisers to reclaim their payments
            assert!(
                matches!(self.state, InvoiceState::Rejected),
                "Payments can only be reclaimed when the invoice is in state Rejected"
            );

            // Load the AdCost item's data
            let mut ad_cost: AdCost = load_non_fungible_data(self.ad_costs.resource_address(), ad_cost_id.clone());
            // Assert that it has not been reclaimed already
            assert!(
                !matches!(ad_cost.state, AdCostState::Reclaimed),
                "The funds for the given AdCost item have already been reclaimed"
            );

            let ad_id = ad_cost.ad_id.clone();
            let reclaimable_amount = ad_cost.amount;

            // Remember that the ad costs have been claimed and save the updated cost item to the ledger
            ad_cost.state = AdCostState::Reclaimed;
            self.minter.update_non_fungible(self.ad_costs.resource_address(), &ad_cost_id, ad_cost);

            // Finally, take the reclaimable amount of funds out of the components vault and
            // redeposit it into the RadSense component to the benefit of the ad's budget
            self.rad_sense_access_badge.authorize(|| {
                let rad_sense_component: RadSenseComponent = self.rad_sense_component.into();
                let reclaimable_funds = self.funds.take(reclaimable_amount);
                rad_sense_component.redeposit_ad_budget(ad_id, reclaimable_funds);
            });
        }
    }
}

/// The invoice's configuration
#[derive(TypeId, Describe, Encode, Decode, new, Debug)]
pub struct InvoiceConfig {
    /// The relevant RadSense resource addresses
    rad_sense_addresses: RadSenseAddresses,
    /// The IF of the ad broker who created the invoice
    ad_broker_user_id: NonFungibleId,
    /// The number of epochs advertisers have to confirm their ad costs
    confirmation_period: u64,
    /// The fee ratio the ad broker is deducting from the payments of advertisers before sending it along to ad slot
    /// providers. Must be in range [0,1].
    broker_fee_ratio: Decimal,
}

impl InvoiceConfig {
    /// Asserts that this invoice is valid by checking the confirmation period is at least one epoch and
    /// the broker fee ratio is in the required range
    pub(crate) fn assert_valid(&self) {
        assert!(self.confirmation_period > 0, "confirmation_period must be > 0");
        assert!(
            self.broker_fee_ratio >= dec!(0) && self.broker_fee_ratio <= dec!(1),
            "broker_fee_ratio must be in range [0..1]"
        );
    }
}

/// A struct containing the resource addresses of AdCost and AdSlotRevenue items
#[derive(TypeId, Describe, Encode, Decode, new, Debug)]
pub struct InvoiceAddresses {
    /// The resource address of AdCost NFRs
    pub ad_cost_resource: ResourceAddress,
    /// The resource address of AdSlotRevenue NFRs
    pub ad_slot_revenue_resource: ResourceAddress,
}

/// DTO for either an AdCost or and AdSlotRevenue item
#[derive(TypeId, Describe, Encode, Decode, new, Debug)]
pub enum InvoiceItem {
    /// An ad cost item
    AdCost {
        /// The ID of the Ad NFR this cost item pertains to
        ad_id: NonFungibleId,
        /// The cost amount
        /// This is simply the product of the price per click of the ad and the number of times it has been clicked
        amount: Decimal,
    },
    /// An ad slot revenue item
    AdSlotRevenue {
        /// The ID of the AdSlot NFR this revenue item pertains to
        ad_slot_id: NonFungibleId,
        /// The revenue amount
        /// This is simply the sum of the price per click of all the ads that have been displayed in this slot times
        /// their price per click
        amount: Decimal,
    },
}

/// Non-fungible data of an ad cost item of the invoice
#[derive(NonFungibleData, new, Debug)]
struct AdCost {
    /// The ID of the Ad NFR this cost item pertains to
    ad_id: NonFungibleId,
    /// The cost amount
    amount: Decimal,
    /// The state of the cost item
    #[scrypto(mutable)]
    state: AdCostState,
}

/// The state of an AdCost item
#[derive(TypeId, Describe, Encode, Decode, Debug)]
enum AdCostState {
    /// The ad cost item has not been confirmed as valid by the advertiser user
    Unconfirmed,
    /// The ad cost item has been confirmed as valid by the advertiser user
    Confirmed,
    /// The payment for the ad cost item has been reclaimed by the advertiser after the invoice was rejected as invalid.
    Reclaimed,
}

/// An ad slot revenue item of the invoice
#[derive(NonFungibleData, new, Debug)]
struct AdSlotRevenue {
    /// The ID of the AdSlot NFR this revenue item pertains to
    ad_slot_id: NonFungibleId,
    /// The revenue amount
    amount: Decimal,
    /// Whether the earnings have already been claimed for this revenue item
    #[scrypto(mutable)]
    claimed: bool,
}

/// The various states of an invoice
#[derive(TypeId, Describe, Encode, Decode, new, Clone, Debug)]
pub enum InvoiceState {
    /// The invoice is being prepared by the ad broker. No other users can interact with it yet.
    Preparing,

    /// The invoice has been published by the ad broker. Now its the users' turn to interact with the invoice.
    /// Especially the advertiser must now confirm their ad costs.
    Published {
        /// An URL pointing to a document that contaisn all details of an invoice that are necessary to verify all the
        /// cost and revenue items on it are correct.
        proof_document_url: String,
        /// A SHA256 hash of the proof document
        proof_document_hash: String,
        /// The epoch until which (inclusive) advertisers can confirm their ad costs
        confirmation_deadline: u64,
        /// The number of unconfirmed ad cost items
        unconfirmed_ad_costs_count: Decimal,
    },
    /// The invoice has been disputed by one or multiple users
    Disputed(Disputers),
    /// The invoice has been accepted by all advertisers and no one has disputed it
    /// Ad slot providers can now claim their earnings and the ad broker can claim their fee
    Accepted {
        /// The number of ad slot revenue items for which the earning have not been claimed.
        /// It is necessary to keep track of this number, as the last user may claim all remaining funds, thus working
        /// around any rounding issues.
        unclaimed_ad_slot_revenues_count: Decimal,
    },
    /// The invoice has been rejected by the arbitrators after having been disputed by users
    Rejected,
}

/// The possible disputers of an invoice
#[derive(TypeId, Describe, Encode, Decode, new, Clone, Debug)]
pub enum Disputers {
    /// An individual user has disputed the invoice (first user to call the `dispute_invoice` method)
    IndividualUser(NonFungibleAddress),
    /// Representative value for all users that did not confirm their ad costs before the confirmation deadline
    AllWithUnconfirmedAdCosts,
}

/// An enum representing a request for disputing an invoice
#[derive(TypeId, Describe, Encode, Decode, new, Clone, Debug)]
pub enum DisputeInvoiceRequest {
    /// Request to dispute an ad cost item
    DisputeAdCost {
        /// The ID of the AdCostItem to dispute
        ad_cost_id: NonFungibleId,
        /// Proof that the caller owns the ad, which is referenced by the disputed ad cost item
        ad_proof: Proof,
    },
    /// Request to dispute an ad slot revenue item
    DisputeAdSlotRevenue {
        /// The ID of the AdSlotRevenueItem to dispute
        ad_slot_revenue_id: NonFungibleId,
        /// Proof that the caller owns the ad slot, which is referenced by the disputed ad slot revenue item
        ad_slot_proof: Proof,
    },
}

/// Helper function for loading the data of a non-fungible resource
///
/// # Arguments:
/// - `resource` - The resource address of the non-fungible
/// - `id` - The ID of the non-fungible
///
/// # Returns
/// The non-fungible data
///
/// **Panics:** if the non-fungible does not exist
fn load_non_fungible_data<T: NonFungibleData>(resource: ResourceAddress, id: NonFungibleId) -> T {
    let rm = borrow_resource_manager!(resource);
    rm.get_non_fungible_data(&id)
}
