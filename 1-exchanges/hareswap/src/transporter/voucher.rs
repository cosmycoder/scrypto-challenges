//! A [Voucher] implementation for the Radix Engine.  Supports
//! cryptographically-secured off-ledger representions of on-ledger assets that
//! exist or may exist in the future.
//!
//! This module is the most low-level and complex part of [transporter].
//! It uses internal details of Scrypto for fun and profit
//! 
//! [transporter]: super
use hex;

use sbor::{describe::Type, Decode, DecodeError, Decoder, Describe, Encode, TypeId};
use scrypto::prelude::*;

use super::authentication::*;
use super::decoder::*;

/// The PassThruNFD implementation and related traits exist so Vouchers can serialize and deserialize
/// NonFungibleData without knowing the type.  Using this, the Transporter can mint NonFungibles at runtime without
/// ever having to know at compile time which NonFungibleData structures may be "redeemed"
#[derive(PartialEq, Eq, Debug, TypeId, Encode, Decode, Describe)]
pub struct PassThruNFD {
    immutable_data: Vec<u8>,
    mutable_data: Vec<u8>,
}

/// a marker trait with a generic impl below so any NonFungibleData can be serialized to a PassThruNFD and thus used with a Voucher
/// NOTE: we can't implement From because of some complex compiler and generics restrictions in Rust stable.  That's ok, we just choose
/// a more specific method name instead and only really expect `as_passthru` to be used internally anyway.
pub trait IsPassThruNFD: NonFungibleData + Sized {
    fn as_passthru(&self) -> PassThruNFD {
        PassThruNFD {
            immutable_data: self.immutable_data(),
            mutable_data: self.mutable_data(),
        }
    }
}
// makes as_passthru available for all NonFungibleData
impl<T: NonFungibleData> IsPassThruNFD for T {}

/// The "other side" of the serialize/deserialize implementation for PassThruNFD.  Allows Scrypto calls that expect a NonFungleData implementation to unknowingly
/// support the PassThruNFD implementation needed for Vouchers.  This is probably the "most sneaky" code in here.
impl NonFungibleData for PassThruNFD {
    /// Decodes `Self` from the serialized immutable and mutable parts.
    fn decode(immutable_data: &[u8], mutable_data: &[u8]) -> Result<Self, DecodeError> {
        Ok(PassThruNFD {
            immutable_data: immutable_data.into(),
            mutable_data: mutable_data.into(),
        })
    }

    /// Returns the serialization of the immutable data part.
    fn immutable_data(&self) -> Vec<u8> {
        self.immutable_data.clone() // NOTE: could optimize to avoid this clone using RefCell<Option<...>> knowing this is only called from mint_non_fungible called from to_bucket which consumes the Voucher
    }

    /// Returns the serialization of the mutable data part.
    fn mutable_data(&self) -> Vec<u8> {
        self.mutable_data.clone() // NOTE: could optimize to avoid this clone using RefCell<Option<...>> knowing this is only called from mint_non_fungible called from to_bucket which consumes the Voucher
    }

    /// Returns the schema of the immutable data.
    fn immutable_data_schema() -> Type {
        panic!("unimplemented"); // not needed to decode a PassThruNFD
    }

    /// Returns the schema of the mutable data.
    fn mutable_data_schema() -> Type {
        panic!("unimplemented"); // not needed to decode a PassThruNFD
    }
}

// make the Voucher not Decode-able so it can't be (accidentally) created other than from SealedVoucher (with sig check)

/// A Voucher is an opaque representation of a NonFungible asset meant to be signed off-ledger and redeemed for a real (minted asset) on-ledger
///
/// NOTE: it explicitly does NOT derive `Decode`.  This is because of ambiguity
/// in the implementation generated by the derive macro.  By not derviving
/// Decode we avoid the compile error and effectively disable passing Voucher's
/// between method calls which is a nice side effect to prevent accidental
/// misuse.  See `PrivateDecode` for more.
#[derive(PartialEq, Eq, Debug, TypeId, Describe, Encode)]
pub struct Voucher {
    /// the resource the Voucher represents
    resource_def: ResourceDef,
    /// the NonFungibleKey for the asset the Voucher represents.  Optional because the redeemer may be expected to provide that information
    key: Option<NonFungibleKey>,
    /// the NonFungibleData for the asset the Voucher represents, but serialized as a PassThruNFD to make everything work at runtime.
    nfd: PassThruNFD,
}


impl Voucher {
    /// Mint the asset represented by this Voucher and return it.
    ///
    /// Caller must supply requirements that match the Voucher metadata (ie. resource and key).
    /// If a requied_key is supplied it must match the Voucher's metadata if present, or it will be used to define
    /// the minted asset's key.  At least one of the Voucher or caller must supply a NonFungibleKey.  If both supply one they must match.
    ///
    /// auth must have MAY_MINT authority for the resource (and of course the resource must be MINTABLE)
    ///
    /// # PANICS
    ///
    /// Will panic if requirements arguments don't match the Voucher or if anything goes wrong while minting.
    pub fn redeem(
        self,
        required_resource_def: &ResourceDef,
        required_key: Option<NonFungibleKey>,
        auth: BucketRef,
    ) -> Bucket {
        let Voucher {
            mut resource_def,
            key,
            nfd,
        } = self;
        assert_eq!(
            resource_def, *required_resource_def,
            "Voucher::redeem: resource requirement not met"
        );
        // test key against required key if both exist, otherwise use whichever is given.  panic if both are None
        let key = match required_key {
            None => key.unwrap(),
            Some(required_key) => {
                if let Some(voucher_key) = key {
                    assert_eq!(voucher_key, required_key, "Voucher::redeem: key requirement not met");
                }
                required_key
            }
        };
        // finally mint
        resource_def.mint_non_fungible(&key, nfd, auth)
    }

    /// create a Voucher from any NonFungibleData with the the included metadata
    ///
    /// Including Some key will ensure that key is the only value which can be redeemed.
    /// A None key lets the redeemer decide the key
    pub fn from_nfd<T: NonFungibleData>(resource_def: ResourceDef, key: Option<NonFungibleKey>, nfd: T) -> Voucher {
        Voucher {
            resource_def,
            key,
            nfd: nfd.as_passthru(), // calling as_passthru is the "trick" and is an implementation detail for how Vouchers work which can be ignored for users.
        }
    }

    /// create a SealedVoucher from this Voucher and an opaque signature
    pub fn to_sealed(&self, signature: Vec<u8>) -> SealedVoucher {
        SealedVoucher {
            serialized: scrypto_encode(self),
            signature,
        }
    }
}


impl PrivateDecode for Voucher {
    /// Decode a SBOR byte stream representing a Voucher back into one.
    ///
    /// This is required because PassThruNFD::decode is ambiguous since it
    /// implements traits for both sbor:Decode and NonFungibleData which both
    /// have a method named `decode`
    ///
    /// Based on the derive Decode implementation  in sbor-derive:src/decode.rs
    fn decode_value(decoder: &mut Decoder) -> Result<Self, DecodeError> {
        let index = decoder.read_u8()?;
        if index != ::sbor::type_id::FIELDS_TYPE_NAMED {
            return Err(::sbor::DecodeError::InvalidIndex(index));
        }
        decoder.check_len(3)?;
        let resource_def = ResourceDef::decode(decoder)?;
        let key = Option::<NonFungibleKey>::decode(decoder)?;
        // cannot derive Decode for Voucher because the decode method is
        // implemented for both  NonFungibleData and Decode traits.
        // Disambiguate here using "as sbor::Decode"
        let nfd = <PassThruNFD as sbor::Decode>::decode(decoder)?;
        decoder.check_end()?;
        Ok(Voucher { resource_def, key, nfd })
    }
}


/// An opaque data structure which can (only) be converted back into a Voucher by validating the digital signature
#[derive(TypeId, Describe, Encode, Decode)]
pub struct SealedVoucher {
    serialized: Vec<u8>,
    signature: Vec<u8>,
}

impl SealedVoucher {
    /// Converts a SealedVoucher back to a Voucher by verifying the signature against public_key.__rust_force_expr!
    ///
    /// # PANICS
    ///
    /// Will panic if the signature does not verify or the data can not be decoded into a Voucher.
    pub fn unseal(&self, public_key: &EcdsaPublicKey) -> Voucher {
        debug!("SealedVoucher::unseal: serialized: {}", hex::encode(&self.serialized));
        debug!("SealedVoucher::unseal:  signature: {}", hex::encode(&self.signature));
        verify_or_panic(public_key, &self.serialized, &self.signature); // NOTE: panics on failure
        private_decode_with_type(&self.serialized).unwrap()
    }
}
